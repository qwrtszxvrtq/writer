<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="style-x2.css">
</head>
<body>
  <textarea id="t" spellcheck="false"></textarea>
  <script>
    (function () {
      var el = document.getElementById("t");
      if (!el) return;

      var KEY_STORAGE = "content";
      var KEY_CRYPTO = "autoEncKey";
      var KEY_TAB = 9;
      var KEY_ENTER = 13;

      function safeGet(key) {
        try { return localStorage.getItem(key); } catch (e) { return null; }
      }
      function safeSet(key, value) {
        try { localStorage.setItem(key, value); } catch (e) {}
      }

      function scrollToCaret(elm) {
        var pos = elm.selectionStart;
        var lineCount = elm.value.slice(0, pos).split("\n").length;
        var lineHeight = parseFloat(window.getComputedStyle ? getComputedStyle(elm).lineHeight : 8) || 8;
        elm.scrollTop = lineHeight * (lineCount - 1);
      }

      function getIndentAt(text, pos) {
        var lineStart = text.lastIndexOf("\n", pos - 1) + 1;
        var m = text.slice(lineStart, pos).match(/^[ ]*/);
        return m ? m[0] : "";
      }

      function applyTab(elm) {
        var p = elm.selectionStart;
        elm.setRangeText("    ", p, p, "end");
        elm.selectionStart = elm.selectionEnd = p + 4;
      }

      function applyEnter(elm) {
        var v = elm.value;
        var pos = elm.selectionStart;
        var indent = getIndentAt(v, pos);
        elm.setRangeText("\n" + indent, pos, pos, "end");
      }

      function stopEvent(e) {
        e = e || window.event;
        if (e.preventDefault) e.preventDefault();
      }
      function isKey(e, code) {
        return e.keyCode === code || (code === KEY_TAB && e.key === "Tab") || (code === KEY_ENTER && e.key === "Enter");
      }

      var hasCrypto = typeof crypto !== "undefined" && crypto.subtle && typeof TextEncoder !== "undefined";

      if (!hasCrypto) {
        el.value = safeGet(KEY_STORAGE) || "";
        el.focus();
        el.oninput = function () {
          safeSet(KEY_STORAGE, el.value);
          scrollToCaret(el);
        };
        el.onkeydown = function (e) {
          e = e || window.event;
          if (isKey(e, KEY_TAB)) {
            stopEvent(e);
            applyTab(el);
            safeSet(KEY_STORAGE, el.value);
          } else if (isKey(e, KEY_ENTER)) {
            stopEvent(e);
            applyEnter(el);
            safeSet(KEY_STORAGE, el.value);
            scrollToCaret(el);
          }
        };
        ["keyup", "click", "touchend"].forEach(function (ev) {
          el.addEventListener(ev, function () { scrollToCaret(el); });
        });
        return;
      }

      var enc = new TextEncoder();
      var dec = new TextDecoder();

      var keyPromise = null;
      function getKey() {
        if (keyPromise) return keyPromise;
        var raw = safeGet(KEY_CRYPTO);
        if (!raw) {
          raw = crypto.getRandomValues(new Uint8Array(32));
          safeSet(KEY_CRYPTO, btoa(String.fromCharCode.apply(null, raw)));
        } else {
          raw = Uint8Array.from(atob(raw), function (c) { return c.charCodeAt(0); });
        }
        keyPromise = crypto.subtle.importKey("raw", raw, "AES-GCM", false, ["encrypt", "decrypt"]);
        return keyPromise;
      }

      function encrypt(text) {
        return getKey().then(function (key) {
          var iv = crypto.getRandomValues(new Uint8Array(12));
          return crypto.subtle.encrypt(
            { name: "AES-GCM", iv: iv },
            key,
            enc.encode(text)
          ).then(function (cipher) {
            return btoa(JSON.stringify({ iv: Array.from(iv), data: Array.from(new Uint8Array(cipher)) }));
          });
        });
      }

      function decrypt(b64) {
        var payload = JSON.parse(atob(b64));
        var iv = new Uint8Array(payload.iv);
        var data = new Uint8Array(payload.data);
        return getKey().then(function (key) {
          return crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, key, data);
        }).then(function (plain) {
          return dec.decode(plain);
        });
      }

      function persistContent() {
        encrypt(el.value).then(function (cipher) {
          safeSet(KEY_STORAGE, cipher);
        });
      }

      var stored = safeGet(KEY_STORAGE);
      if (!stored) {
        el.value = "";
        el.focus();
      } else {
        decrypt(stored).then(function (text) { el.value = text; }).catch(function () { el.value = ""; }).then(function () { el.focus(); });
      }

      el.addEventListener("input", function () {
        persistContent();
        scrollToCaret(el);
      });

      el.addEventListener("keydown", function (e) {
        e = e || window.event;
        if (isKey(e, KEY_TAB)) {
          stopEvent(e);
          applyTab(el);
          persistContent();
        } else if (isKey(e, KEY_ENTER)) {
          stopEvent(e);
          applyEnter(el);
          persistContent();
          scrollToCaret(el);
        }
      });

      ["keyup", "click", "touchend"].forEach(function (ev) {
        el.addEventListener(ev, function () { scrollToCaret(el); });
      });
    })();
  </script>
</body>
</html>
